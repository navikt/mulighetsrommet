package no.nav.mulighetsrommet.database.kotest.extensions

import io.kotest.core.listeners.AfterSpecListener
import io.kotest.core.listeners.BeforeSpecListener
import io.kotest.core.spec.Spec
import io.kotest.core.test.TestCaseOrder
import kotliquery.TransactionalSession
import kotliquery.queryOf
import no.nav.mulighetsrommet.api.ApiDatabase
import no.nav.mulighetsrommet.api.QueryContext
import no.nav.mulighetsrommet.database.Database
import no.nav.mulighetsrommet.database.DatabaseConfig
import no.nav.mulighetsrommet.database.FlywayMigrationManager
import org.assertj.db.api.Assertions
import org.assertj.db.api.TableAssert
import org.assertj.db.type.AssertDbConnectionFactory

class ApiDatabaseTestListener(private val config: DatabaseConfig) : BeforeSpecListener, AfterSpecListener {
    private var delegate: Database? = null

    private val flywayMigration: FlywayMigrationManager = FlywayMigrationManager(
        config = FlywayMigrationManager.MigrationConfig(cleanDisabled = false),
        slackNotifier = null,
    )

    val db: ApiDatabase
        get() {
            return delegate?.let { ApiDatabase(it) } ?: throw RuntimeException("Database has not yet been initialized")
        }

    override suspend fun beforeSpec(spec: Spec) {
        // It's not optimal to force a sequential test order, but since tests (for now) all share the same database
        // instance they can't be run in parallel
        spec.testOrder = TestCaseOrder.Sequential

        delegate = Database(config)

        flywayMigration.migrate(db.db)
    }

    override suspend fun afterSpec(spec: Spec) {
        truncateAll()
        delegate?.close()
    }

    fun assertTable(tableName: String): TableAssert {
        val connection = AssertDbConnectionFactory.of(db.getDatasource()).create()
        val table = connection.table(tableName).build()
        return Assertions.assertThat(table)
    }

    inline fun <T> run(block: QueryContext.(TransactionalSession) -> T): T = db.transaction {
        block(session as TransactionalSession)
    }

    inline fun <T> runAndRollback(block: QueryContext.(TransactionalSession) -> T): T = db.db.session { s ->
        try {
            s.connection.begin()
            s.transactional = true
            val tx = TransactionalSession(s.connection, s.returnGeneratedKeys, s.autoGeneratedKeys, s.strict)
            val context = QueryContext(tx)
            return block.invoke(context, tx)
        } finally {
            s.connection.rollback()
            s.transactional = false
            s.close()
        }
    }

    fun truncateAll() {
        val tableNames =
            queryOf("SELECT table_name FROM information_schema.tables WHERE table_schema='public' AND table_type='BASE TABLE'")
                .map { it.string("table_name") }
                .asList
                .let { db.db.run(it) }
        tableNames.forEach {
            db.db.run(queryOf("truncate table $it restart identity cascade").asExecute)
        }
    }
}
